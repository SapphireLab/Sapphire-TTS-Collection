# A Survey of Deep Learning Audio Generation Methods

<details>
<summary>基本信息</summary>

- 标题: "A Survey of Deep Learning Audio Generation Methods"
- 作者:
  - 01 Matej Božić (University of Zagreb, 克罗地亚萨格勒布大学)
  - 02 Marko Horvat (University of Zagreb, 克罗地亚萨格勒布大学)
- 链接:
  - [ArXiv](https://arxiv.org/abs/2406.00146)
  - [Publication]()
  - [Github]()
  - [Demo]()
- 文件:
  - [ArXiv](PDF/S20240531__A_Survey_of_Deep_Learning_Audio_Generation_Methods[2406.00146v1].pdf)
  - [Publication] #TODO

</details>

## Abstract: 摘要

<table><tr><td width="50%">

This article presents a review of typical techniques used in three distinct aspects of deep learning model development for audio generation.
In the first part of the article, we provide an explanation of audio representations, beginning with the fundamental audio waveform.
We then progress to the frequency domain, with an emphasis on the attributes of human hearing, and finally introduce a relatively recent development.
The main part of the article focuses on explaining basic and extended deep learning architecture variants, along with their practical applications in the field of audio generation.
The following architectures are addressed: (1) Autoencoders (2) Generative adversarial networks (3) Normalizing flows (4) Transformer networks (5) Diffusion models.
Lastly, we will examine four distinct evaluation metrics that are commonly employed in audio generation.
This article aims to offer novice readers and beginners in the field a comprehensive understanding of the current state of the art in audio generation methods as well as relevant studies that can be explored for future research.

</td><td>

本文对音频生成领域深度学习模型开发中使用的典型技术进行了综述, 涵盖了三个不同的方面.
在文章的第一部分, 我们首先解释了音频表示, 从基本的音频波形开始.
随后, 我们转向频域, 强调了人类听觉的特性, 并最终介绍了一项相对较新的发展.
文章的主体部分专注于解释基础和扩展的深度学习架构变体, 以及它们在音频生成领域的实际应用.
以下架构得到了讨论: (1) 自编码器 (2) 生成对抗网络 (3) 归一化流 (4) Transformer 网络 (5) 扩散模型.
最后, 我们将探讨音频生成中常用的四种不同的评估指标.
本文旨在为该领域的初学者和新手提供对音频生成方法当前技术水平的全面理解, 以及可供未来研究探索的相关研究.

</td></tr></table>

## 1.Introduction: 引言 <a id="sec.intro"></a>

<table><tr><td width="50%">

The trend towards deep learning in Computer Vision (CV) and Natural Language Processing (NLP) has also reached the field of audio generation[^001].
Deep learning has allowed us to move away from the complexity of hand-crafted features towards simple representations by letting the depth of the model create more complex mappings.
We define audio generation as any method whose outputs are audio and cannot be derived solely from the inputs.
Even though tasks such as text-to-speech involve translation from the text domain to the speech domain, there are many unknowns, such as the speaker's voice.
This means that the models have to invent or generate information for the translation to work.
There are many applications for audio generation.
We can create human-sounding voice assistants, generate ambient sounds for games or movies based on the current visual input, create various music samples to help music producers with ideas or composition, and much more.
The structure of the presented survey on deep learning audio generation methods is illustrated in [Figure.01](#Fig.01).

</td><td>

深度学习在计算机视觉 (CV) 和自然语言处理 (NLP) 领域的趋势也已触及音频生成领域 (001).
深度学习使我们能够摆脱手工特征的复杂性, 转而通过模型的深度创建更复杂的映射.
我们定义音频生成为任何输出为音频且不能仅从输入推导出的方法.
尽管诸如文本到语音的任务涉及从文本域到语音域的转换, 但存在许多未知因素, 如说话者的声音.
这意味着模型必须发明或生成信息以使转换生效.
音频生成的应用广泛, 我们可以创造听起来像人类的语音助手, 根据当前视觉输入为游戏或电影生成环境声音, 创造各种音乐样本帮助音乐制作人获得灵感或进行作曲, 等等.
本文介绍的深度学习音频生成方法调查结构如[图 01](#Fig.01) 所示.

</td></tr>
<tr><td colspan="2">

![](Images/2024.05.31_Fig.01.png)

<a>Figure.01: The main sections of the survey.</a>

</td></tr>
<tr><td>

This article will mainly focus on deep learning methods, as the field seems to be developing in this direction.
Nevertheless, [Section.03](#sec.background) will examine the development of audio generation methods over the years, starting around the 1970s.
We consider this section important because, just as deep learning methods have re-emerged, there may be a time when audio generation methods that are now obsolete become state-of-the-art again.
The goal is to take a broad but shallow look at the field of audio generation.
Some areas, such as text-to-speech, will be more heavily represented as they have received more attention, but an attempt has been made to include many different subfields.
This article does not attempt to present all possible methods but only introduces the reader to some of the popular methods in the field.
Each listing of works on a topic is sorted so that the most recent articles are at the end.

</td><td>

本文将主要聚焦于深度学习方法, 因为该领域正向着此方向发展.
不过, [背景一节](#sec.background)将考察音频生成方法在过去几十年的发展, 从 1970 年代开始.
我们认为这一节很重要, 因为正如深度学习方法重新兴起一样, 现在看似过时的音频生成方法有朝一日可能会再次成为最先进的技术.
我们的目标是广泛但浅显地了解音频生成领域.
某些如文本转语音等领域将得到更多的关注, 因为它们目前受到了更多的关注, 但我们也试图涵盖许多不同的子领域.
本文并不试图展示所有可能的方法, 而只是向读者介绍该领域中一些流行的方法.
每个主题的相关工作都经过排序, 以便最新的文章位于末尾.

</td></tr>
<tr><td>

The article is structured as follows:
- [Section.02](#sec.related_work) presents previous work dealing with deep learning in audio,
- [Section.03](#sec.background) gives a brief overview of previous audio generation methods in text-to-speech and music generation,
- [Section.04](#sec.audio_features) deals with the two most prominent features and a recent advancement,
- [Section.05](#sec.architectures) discusses five deep learning architectures and some of their popular extensions, and finally,
- [Section.06](#sec.eval_metrics) looks at measuring the performance of generation models, some of which are specific to audio generation, while others are more generally applicable.

</td><td>

文章的结构如下：
- [相关工作一节](#sec.related_work)将展示与音频领域深度学习相关的先前研究;
- [背景一节](#sec.background)将简要概述文本到语音和音乐生成领域中以往的音频生成方法;
- [音频特征一节](#sec.audio_features)将探讨两个最显著的音频特征以及一项最近的进展;
- [架构一节](#sec.architectures)将讨论五种深度学习架构及其一些流行的扩展;
- 最后, [评估指标一节](#sec.eval_metrics)将探讨生成模型的性能测量方法, 其中一些指标专门针对音频生成, 而其他指标则具有更广泛的适用性.

</td></tr></table>

## 2.Related Works: 相关工作

<a id="sec.related_work"></a>

<table><tr><td width="50%">

In this section, we will mention some of the works that are good sources for further research in the field of audio generation.
Some of them investigate only a specific model architecture or sub-area, while others, like this work, show a broader view.

</td><td>

在本节中, 我们将提及一些在音频生成领域进行深入研究的良好资源.
其中一些仅研究特定的模型架构或子领域, 而其他的一些, 如本文, 则呈现了一个更广泛的视角.

</td></tr>
<tr><td>

In [^002], deep learning discriminative and generative architectures are discussed, along with their applications in speech and music synthesis.
The article covers discriminative neural networks such as Multi-Layer Perceptron (MLP), Convolutional Neural Networks (CNN), and Recurrent Neural Networks (RNN), as well as generative neural networks like Variational Autoencoders (VAE) and Deep Belief Networks (DBN).
They also describe generative adversarial networks (GAN), their flaws, and enhancement strategies (with Wasserstein GAN as a standout).
The study mainly focuses on speech generation and doesn't focus much on different hybrid models.

</td><td>

在 [^002] 中, 讨论了深度学习的判别性和生成性架构, 以及它们在语音和音乐合成中的应用.
文章涵盖了判别性神经网络, 如多层感知机 (Mulit-Layer Perceptron, MLP), 卷积神经网络 (Convolutional Neural Networks, CNN), 循环神经网络 (Recurrent Neural Networks, RNN), 以及生成性神经网络, 如变分自编码器 (Variational Autoencoders, VAE) 和深度置信网络 (Deep Belief Networks, DBN).
文章还描述了生成对抗网络 (Generative Adversarial Networks, GAN), 相应缺陷, 以及增强策略 (特别是 Wasserstein GAN).
该研究主要集中在语音生成上, 并未过多关注不同的混合模型.

</td></tr>
<tr><td>

In contrast, [^003] emphasizes other areas of modeling, including feature representations, loss functions, data, and evaluation methods.
It also investigates a variety of additional application fields, including enhancement as well as those outside of audio generation, such as source separation, audio classification, and tagging.
They describe various audio aspects that are not covered here, such as the mel frequency cepstral coefficients (MFCC) and the constant-Q spectrogram.
They do not cover as many architectures, but they do provide domain-specific datasets and evaluation methods.

</td><td>

相比之下, [^003] 注重于其他领域的建模, 如特征表示, 损失函数, 数据和评价方法.
它还探讨了额外的各种应用领域, 包括增强以及音频生成之外的领域, 如声源分离, 语音分类和标记.
他们描述了本文未涉及到的各种音频方面, 例如梅尔频率倒谱系数 (Mel Frequency Cepstral Coefficients, MFCC) 和常量 Q 频谱图.
他们并未涉及如本文这么多的架构, 但提供了特定领域的数据集和评价方法.

</td></tr>
<tr><td>

Unlike previous works, [^004] attempts to comprehensively examine a specific field of audio generation.
This study considers five dimensions of music generation: objective, representation, architecture, challenge, and strategy.
It looks at a variety of representations, both domain-specific and more general.
Explains the fundamentals of music theory, including notes, rhythm, and chords.
Introduces various previously established architectures such as MLP, VAE, RNN, CNN, and GAN, as well as some new ones like the Restricted Boltzmann Machine (RBM).
Finally, it discusses the many challenges of music generation and ways for overcoming them.
The work is quite extensive; however, some sections may benefit from a more detailed explanation.

</td><td>

和之前的工作不同, [^004] 尝试全面地审视音频生成的一个特定领域.
该研究考虑音乐生成的五个维度: 目标, 表示, 架构, 挑战, 策略.
它考察了各种表示, 包括特定领域和更通用的.
解释了音乐理论的基础, 包括音符, 节奏和和弦.
介绍了各种先前建立的架构, 如 MLP, VAE, RNN, CNN, GAN, 以及一些新的架构, 如受限玻尔兹曼机 (Restricted Boltzmann Machine, RBM).
最后, 讨论了音乐生成的许多挑战, 以及如何克服这些挑战的方法.
该研究相当广泛, 但某些部分可能需要更详细的解释.

</td></tr>
<tr><td>

[^005] is another work that explores the subject of music generation and includes music translation.
It discusses data representation, generative neural networks, and two popular DNN-based synthesizers.
It discusses the issue of long-term dependence and how conditioning might alleviate it.
Explains the autoregressive (AR) and normalized flow (NF) models, as well as VAE and GAN.

</td><td>

[^005] 是另一项探讨音乐生成主题的工作, 包括音乐翻译.
它讨论了数据表示, 生成性神经网络和两种流行的基于 DNN 的合成器.
它讨论了长期依赖问题以及条件化如何缓解这一问题.
解释了自回归 (AR) 和归一化流 (NF) 模型, 以及 VAE 和 GAN.

</td></tr>
<tr><td>

[^001] provides an overview of deep learning techniques for audio.
It distinguishes architectures from meta-architectures.
The architectures include MLP, CNN, Temporal Convolutional Networks (TCN), and RNN, while the meta-architectures are Auto-Encoders (AE), VAE, GAN, Encoder/Decoder, Attention Mechanism, and Transformers.
Divides audio representations into three categories: time-frequency, waveform, and knowledge-driven.
Time-frequency representations include the Short-Time Fourier Transform (STFT), MFCC, Log-Mel-Spectrogram (LMS), and Constant-Q-Transform (CQT).
The article concludes with a list of applications for audio deep learning algorithms, including music content description, environmental sound description, and content processing.
It also briefly discusses semi-supervised and self-supervised learning.

</td><td>

[^001] 提供了深度学习技术在音频领域的概述.
它区分了架构和元架构.
架构包括 MLP, CNN, 时域卷积网络 (Temporal Convolutional Networks, TCN), 和 RNN, 而元架构包括自编码器 (Auto-Encoders, AE), VAE, GAN, 编码器-解码器 (Encoder/Decoder), 注意力机制 (Attention Mechanism), 和 Transformers.
它将音频表示分为三类: 时频, 波形, 知识驱动.
其中时频表示包括短时傅里叶变换 (Short-Time Fourier Transform, STFT), MFCC, 对数梅尔频率谱图 (Log-Mel-Spectrogram, LMS), 和常量 Q 变换 (Constant-Q-Transform, CQT).
文章最后列出了音频深度学习算法的应用, 包括音乐内容描述, 环境声音描述和内容处理.
它还简要地讨论了半监督和无监督学习.

</td></tr>
<tr><td>

[^006] provides a comprehensive overview of TTS methods, including history.
It explains the basic components of TTS systems, such as text analysis, acoustic models, and vocoders, and includes a list of models in each area.
Finally, it discusses advanced methods for implementing TTS systems in certain use situations, such as Fast TTS, Low-Resource TTS, and Robust TTS.

</td><td>

[^006] 提供了对文本转语音方法的全面概述, 包括历史.
它解释了文本转语音系统的基本组件, 如文本分析, 声学模型, 声码器, 并列出了每个子领域的模型列表.
最后它讨论了在某些特定使用场景下实施文本转语音系统的先进方法, 如快速 TTS, 低资源 TTS, 和健壮 TTS.

</td></tr>
<tr><td>

[^007] discusses TTS, music generation, audiovisual multi-modal processing, and datasets.
This effort differs from earlier ones in that it organizes relevant articles by category rather than explaining subjects in depth.

</td><td>

[^007] 讨论了 TTS, 音乐生成, 视听多模态处理和数据集.
这项工作与之前的工作不同, 它按类别组织相关文章, 而不是深入解释主题.

</td></tr>
<tr><td>

[^008] is the closest work to this one.
It follows a similar structure, starting with input representations including raw waveforms, spectrograms, acoustic characteristics, embeddings, and symbolic representations, followed by conditioning representations used to guide audio synthesis.
Includes audio synthesis techniques such as AR, NF, GAN, and VAE.
The article concludes with the following evaluation methods: perceptual evaluation, number of statistically different bins, inception score, distance-based measurements, spectral convergence, and log likelihood.

</td><td>

[^008] 与本文最接近.
它遵循类似的结构, 从输入表示开始, 包括原始波形, 频谱图, 声学特征, 嵌入和符号表示, 然后是用于指导音频合成的条件表示.
文章还包括了音频合成技术, 如 AR, NF, GAN 和 VAE.
文章最后介绍了以下评估方法: 感知评估, 统计不同箱的数量, 初始分数, 基于距离的测量, 光谱收敛性和对数似然.

</td></tr>
<tr><td>

[^009] provides an overview of transformer architectures used in the field of speech processing.
The article provides a description of the transformer, a list of popular transformers for speech, and a literature review on its applications.

</td><td>

[^009] 提供了在语音处理领域使用的 Transformer 架构的概述.
文章描述了 Transformer, 列出了用于语音的流行 Transformer, 并对其应用进行了文献综述.

</td></tr>
<tr><td>

[^010] surveys TTS and speech enhancement, with a focus on diffusion models.
Although the emphasis is on diffusion models, they also discuss the stages of TTS, pioneering work, and specialized models for distinct speech enhancement tasks.

</td><td>

[^010] 调查了文本转语音和语音增强, 重点是扩散模型.
虽然重点是扩散模型, 但他们也讨论了 TTS 的阶段, 开创性工作以及针对特定语音增强任务的专业模型.

</td></tr>
<tr><td>

[^011] conducted a comprehensive survey of deep learning techniques in speech processing.
It begins with speech features and traditional speech processing models.
It addresses the following deep learning architectures: RNN, CNN, Transformer, Conformer, Sequence-to-Sequence models (Seq2seq), Reinforcement learning, Graph neural networks (GNN), and diffusion probabilistic networks.
Explains supervised, unsupervised, semi-supervised, and self-directed speech representation learning.
Finally, it discusses a variety of speech processing tasks, including neural speech synthesis, speech-to-speech translation, speech enhancement, audio super resolution, as well transfer learning techniques.

</td><td>

[^011] 进行了一项关于深度学习技术在语音处理中的全面调查.
它从语音特征和传统语音处理模型开始.
它讨论了以下深度学习架构: RNN, CNN, Transformer, Conformer, 序列到序列模型 (Seq2seq), 强化学习, 图神经网络 (GNN) 和扩散概率网络.
解释了监督, 无监督, 半监督和自我导向的语音表示学习.
最后它讨论了各种语音处理任务, 包括神经语音合成, 语音到语音翻译, 语音增强, 音频超分辨率以及转移学习技术.

</td></tr></table>

## 3.Background: 背景

<a id="sec.background"></a>

<table><tr><td width="50%">

The main purpose of this section is to show how audio generation has developed over the years up to this point.
Since audio generation is a broad field that encompasses many different areas, such as text-to-speech synthesis, voice conversion, speech enhancement,... [^012], we will only focus on two different areas of audio generation: text-to-speech synthesis and music generation.
There is no particular reason for this choice, except that they are among the more popular ones.
The trend we want to show is how domain-specific knowledge is shifting towards general-purpose methods and how feature engineering is turning into feature recognition.

</td><td>

本节的主要目的是展示音频生成领域多年来是如何发展到目前这个阶段的.
由于音频生成是一个广泛的领域, 涵盖了许多不同的领域, 如文本到语音合成, 语音转换, 语音增强等 ([^012]),

我们将只关注音频生成的两个不同领域: 文本到语音合成和音乐生成.
这个选择没有特别的理由, 只是因为它们是更受欢迎的领域之一.
我们想要展示的趋势是特定领域知识如何向通用方法转变, 以及特征工程如何转变为特征识别.

</td></tr></table>

### Text-to-Speech: 文本转语音

<table><tr><td width="50%">

Text-to-speech (TTS) is a task with numerous applications, ranging from phone assistants to GPS navigators.
The desire to construct a machine that can communicate with a human has historically fueled growth in this subject.
Conventional speech synthesis technologies include rule-based concatenative speech synthesis (CSS) and statistical parametric speech synthesis (SPSS) [^013].
CSS and SPSS, which employ speech data, may be considered corpus-based speech synthesis approaches [^014].

</td><td>

</td></tr>
<tr><td>

Until the late 1980s, the field was dominated by rule-based systems [^015].
They were heavily reliant on domain expertise such as phonological theory, necessitating the collaboration of many experts to develop a comprehensive rule set that would generate speech parameters.
There are numerous works like [^016]; [^017]; [^018]; [^019].

</td><td>

</td></tr>
<tr><td>

CSS methods try to achieve the naturalness and intelligibility of speech by combining chunks of recorded speech.
They can be divided into two categories: fixed inventory and unit-selection approaches [^013].
Fixed inventory uses only one instance of each concatenative unit, which goes through signal processing before being combined into a spoken word.
An example of this might be [^020], which uses the diphone method of segment assembly.
On the other hand, unit-selection employs a large number of concatenative units, which can result in a better match between adjacent units, potentially boosting speech quality.
There are two fundamental concepts: target cost and concatenation cost.
The target cost determines how well an element from a database of units fits the desired unit, whereas the concatenation cost indicates how well a pair of selected units combine.
The goal is to minimize both costs for the entire sequence of units; this is commonly done using a Viterbi search [^013].
Although it is always possible to minimize costs, the resulting speech may still contain errors.
This can arise owing to a lack of units to choose from, an issue that can be mitigated by increasing the database size.
It sounds straightforward; however, doing so increases unit creation costs and search times due to the increased number of possible concatenations.
All of this requires CSS techniques to pick between speech quality and synthesis speed.
Works in this domain include [^021], where they employ non-uniform synthesis units, and [^022], which treats units of a unit-selection database as states in a state transition network.

</td><td>

</td></tr>
<tr><td>

SPSS models speech parameters using statistical methods depending on the desired phoneme sequence.
This differs from CSS techniques in that we are not maintaining natural, unaltered speech but rather teaching the model how to recreate it.
In a typical SPSS system, this is done by first extracting parametric representations of speech and then modeling them using generative models, commonly by applying the maximum likelihood criterion [^023].
The primary advantage of SPSS over CSS is its ability to generalize to unknown data [^013].
This enables us to adjust the model to generate different voice characteristics [^015].
It also requires orders of magnitude less memory because we use model parameters instead of a speech database.
Although there are other SPSS techniques, the majority of research has centered on hidden Markov models (HMM) [^015].

</td><td>

</td></tr>
<tr><td>

Some HMM works include [^014], which considers not only the output probability of static and dynamic feature vectors but also the global variance (GV).
[^024] directly models speech waveforms with a trajectory HMM.
[^025], [^026] use decision-tree-based context clustering to represent spectrum, pitch, and HMM state duration simultaneously.
Commonly used contexts include the current phoneme, preceding and succeeding phonemes, the position of the current syllable within the current word or phrase, etc[^027].

</td><td>

</td></tr>
<tr><td>

The notion that the human speech system has a layered structure in its transformation of the linguistic level to the waveform level has stimulated the adoption of deep neural network speech synthesis [^028].
[^029] employs an artificial neural network alongside a rule-based method to model speech parameters.
[^030] employs limited Boltzmann machines and deep belief networks to predict speech parameters for each HMM state.
Some other methods worth noting are multi-layer perceptron [^028]; [^031]; [^032]; [^033]; [^034], time-delay neural network [^035]; [^036], long short-term memory [^037]; [^038]; [^039]; [^040], gated recurrent unit [^041], attention-based recurrent network [^042], and mixture density network [^043]; [^041].

</td><td>

</td></tr>
<tr><td>

The TTS system consists of four major components: the first converts text to a linguistic representation, the second determines the duration of each speech segment, the third converts the linguistic and timing representations into speech parameters, and the fourth is the vocoder, which generates the speech waveform based on the speech parameters [^035].
The majority of the works we presented focused on converting the linguistic representation into speech parameters, but there are also models focusing on, for example, grapheme-to-phoneme conversion [^044]; [^045] to allow TTS without knowledge of linguistic features.
Examples of vocoders include MLSA [^046], STRAIGHT [^047], and
Vocaine [^048].
Finally, there have also been attempts to construct a fully end-to-end system, which means integrating text analysis and acoustic modeling into a single model [^042].

</td><td>

</td></tr></table>

### Music Generation: 音乐生成

<table><tr><td width="50%">

Music has been a part of human life long before the invention of the electronic computer, and people have developed many guidelines for how beautifully sounded music should be made.
For this reason alone, the discipline of music generation has placed a heavy emphasis on rule-based systems that use music theory to create logical rules.
Unlike text, musical vocabulary is rather tiny, consisting of at most several hundred discrete note symbols [^049].
Music creation is classified into six categories: grammars, knowledge-based, markov chains, artificial neural networks, evolutionary methods, and self-similarity [^050].
Specific methods include discrete nonlinear maps [^051]; [^052], rule-based [^053]; [^054], genetic algorithm [^055]; [^056]; [^057]; [^058], recurrent neural network [^059]; [^057], long short-term memory [^060]; [^061]; [^062]; [^063], markov chain [^052]; [^064], context-free grammars [^064]; [^058], context-sensitive grammars [^065]; [^066], cellular automaton [^067], random fields [^049], L-systems [^068], knowledge base [^069], and restricted Boltzmann machines [^070].

Unlike language, music employs a significantly smaller number of acoustic features.
These include MIDI representation [^056]; [^062], encoded sheet music [^057], binary vector of an octave [^049], and piano roll [^070]; [^062].

</td><td>

音乐在电子计算机发明之前就已经是人类生活的一部分, 人们已经发展了许多关于如何制作优美音乐的指导原则.
正因如此, 音乐生成的原则在很大程度上依赖于基于规则的系统, 这些系统使用音乐理论来创建逻辑规则.

和文本不同, 音乐的词汇表相当小, 最多包含几百个离散的音符符号.
音乐创作被分为六个类别: 语法, 基于知识, 马尔可夫链, 人工神经网络, 进化方法和自相似性.
具体方法包括离散非线性映射, 基于规则的, 遗传算法, 循环神经网络, 长短期记忆网络, 马尔可夫链, 上下文无关的语法, 上下文敏感的语法, 细胞自动机, 随机场, L-系统, 知识库, 受限玻尔兹曼机.

和语言不同, 音乐使用的声学特征数要少得多.
这些特征包括 MIDI 表示, 编码乐谱, 八度二进制向量, 和自动钢琴打孔纸卷.

</td></tr></table>

## 4.Audio Features: 音频特征 <a id="audio-features"></a>

<table><tr><td width="50%">

Even though there have been numerous audio features used throughout the history of audio generation.
Here we will describe the two most popular features, the raw waveform and the log-mel spectrogram, but also mention features that have recently gained traction.
Keep in mind that there are too many features to describe them all, especially if we take into account the many hand-crafted features that were created before the rise of deep learning methods.

</td><td>

尽管在音频生成的历史中使用了众多的音频特征, 但在这里我们将描述两个最流行的特征: 原始波形和梅尔对数频谱图, 同时也会提及一些最近获得关注的特征.
请记住, 有太多的特征无法描述, 尤其是如果我们考虑到在深度学习方法兴起之前创建的许多手工制作的特征.

</td></tr></table>

### Raw Waveform: 原始波形

<table><tr><td width="50%">

The term "raw audio" typically refers to a waveform recorded using pulse code modulation (PCM) [^008].
In PCM, a continuous waveform is sampled at uniform intervals, known as the sampling frequency.
According to the sampling principle, if a signal is sampled at regular intervals at a rate slightly higher than twice the highest signal frequency, then it will contain all of the original signal information [^071].
The average sample frequency for audio applications is 44.1 kHz [^008], hence we cannot hold frequencies equal to or greater than 22.05 kHz.
Computers cannot store real numbers with absolute precision; thus, each sample value is approximated by assigning it an element from a set of finite values, a technique known as quantization [^008].
The most common quantization levels are kept in 8 bits (256 levels), 16 bits (65536 levels), and 24 bits (16.8 million levels) [^008].

</td><td>

</td></tr>
<tr><td>

The advantage of using raw audio waveforms is that they can be easily transformed into actual sound.
In certain tasks, the disadvantages appear to outweigh the benefits, as raw waveforms are still not universally used.
The issue is that raw audio synthesis at higher bit rates becomes problematic due to the sheer amount of states involved [^072].
For example, 24-bit audio signals have more than 16 million states.
High sampling rates create exceptionally long sequences, making raw audio synthesis more challenging **VALL-E**[^073].
$\mu$-law is frequently employed in speech generative models like **WaveNet**[^074] to compress integer values and sequence length.
The method can quantize each timestep to 256 values and reconstruct high-quality audio **VALL-E**[^073].
According to [^075], increased bit depth representation can lead to models learning undesirable aspects, such as the calm background of the surroundings.
It should be emphasized that this issue was only observed in older publications and is not discussed in current ones.

</td><td>

</td></tr>
<tr><td>

The most common models that use raw waveforms as their representation of choice are text-to-speech models called vocoders.
In [Section.03](#sec.background), we mentioned vocoders, which are used to translate mid-term representations, such as mel-spectrograms, to raw audio waveforms.
Examples include **WaveNet**[^074], **SampleRNN**[^076] and **DeepVoice3**[^077].

</td><td>

</td></tr></table>

### Mel-Spectrogram: 梅尔频谱

<table><tr><td width="50%">

Before we can talk about mel-spectrograms, we must first understand the Short-Time Fourier Transform (STFT).
To represent audio frequencies, we use a Discrete-Fourier Transform (DFT), which transforms the original waveform into a sum of weighted complex exponentials [^078].
The problem emerges when we attempt to analyze complex audio signals; because the content of most audio signals changes over time, we can't use DFT to figure out how frequencies change.
Instead, we use STFT to apply DFT to overlapping sections of the audio waveform [^008].
Most techniques that use the STFT to represent audio consider just its amplitude [^001], which results in a lossy representation.
By removing the phase of the STFT, we can arrange it in a time/frequency visual, creating a spectrogram.

</td><td>

</td></tr>
<tr><td>

A mel-spectrogram compresses the STFT in the frequency axis by projecting it onto a scale known as the mel-scale [^079].
The mel-scale divides the frequency range into a set of mel-frequency bands, with higher frequencies having lower resolution and lower frequencies having higher resolution [^011].
The scale was inspired by the non-linear frequency perception of human hearing [^011].
Applying the logarithm to the amplitude results in the log-mel-spectrogram [^001].
Finally, using the discrete cosine transform yields the mel frequency cepstral coefficients (MFCC) [^003].
MFCC is a popular representation in speech applications [^013], but it was shown to be unnecessary with deep learning models [^003]; [^001].

</td><td>

</td></tr>
<tr><td>

While representations such as the STFT and raw waveform are invertible, the spectrogram is not, so we must use some approach to approximate the missing values.
The algorithms used for these were already mentioned in the previous section.
In addition to neural-based vocoders, other algorithms include Griffin-Lim [^080], gradient-based inversion [^081], single-pass spectrogram inversion (SPSI) [^082], and phase gradient heap integration (PGHI) [^083].
Mel-spectrograms have been frequently utilized as intermediate features in text-to-speech pipelines [^007].
**Tacotron**[^084], **Tacotron2**[^085] and **FastSpeech**[^086], **FastSpeech2**[^087] are examples of such models.
To better illustrate the compression of the mel-spectrogram, take, for example, a 5-minute video sampled at 44.1 kHz.
With 16-bit depth, our raw waveform will take up ${\approx} 25 \text{MB}$, while the mel-spectrogram with a common configuration of 80 bins, 256 hop size, 1024 window size, and 1024 points of Fourier transform takes up ${\approx} 8 \text{MB}$ at the same bit depth.
Note: Common configuration is based on a small sample of articles observed using mel-spectrograms.
In a 2018 article, it was proven that mel-spectrogram is preferable over STFT because it achieves the same performance while having a more compact representation [^088].
Given the field's progress, it should be emphasized that only recurrent and convolutional models were examined in the article.
Another advantage of the mel-spectrogram, and spectrograms in general, is that they can be displayed as images.
Because it ignores phase information, it can be shown with one dimension being frequency and the other being time.
This is useful since images have been widely employed in computer vision tasks, allowing us to borrow models for usage in the audio domain.
There is a concern as spectrograms aren't the same as images due to the different meaning of the axis.
This does not appear to have a substantial effect since many works implement mel-spectrograms in their convolutional models [^001].

</td><td>

</td></tr></table>

### Neural Codecs: 神经编解码

<table><tr><td width="50%">

An audio codec is a signal processing technique that compresses an audio signal into discrete codes before using those codes to reconstruct the audio signal, which is not always possible with complete accuracy.
A typical audio codec system consists of three components: an encoder, a quantizer, and a decoder.
The function of each component is explained in [Section.05](#sec.architectures).
The goal of an audio codec is to use as little information as possible to store or transmit an audio signal while ensuring that the decoded audio quality is not significantly reduced by eliminating redundant or irrelevant information from the audio signal.
Traditionally, this is accomplished by changing the signal and trading off the quality of specific signal components that are less likely to influence the quality **EnCodec**[^089].
Audio codecs have been utilized for a wide range of applications, including mobile and internet communication.
There are numerous types of audio codecs; some are utilized in real-time applications like streaming, while others may be used for audio production.
Whereas in streaming, latency is a larger concern, which means sacrificing quality for speed, in production, we want to retain as much detail as possible while maintaining a compact representation.

</td><td>

</td></tr>
<tr><td>

Audio codecs can be separated into two categories: waveform codecs and parametric codecs.
Waveform codecs make little to no assumptions about the nature of audio, allowing them to work with any audio signal.
This universality makes them well-suited for creating high-quality audio at low compression, but they tend to produce artifacts when operating at high compression **SoundStream**[^090].
Furthermore, because they do not operate well in high compression, they tend to increase storage and transmission costs.
In contrast to waveform codecs, parametric codecs make assumptions about the source audio being encoded and introduce strong priors in the form of a parametric model that characterizes the audio synthesis process.
The goal is not to achieve a faithful reconstruction on a sample-by-sample basis but rather to generate audio that is perceptually comparable to the original **SoundStream**[^090].
Parametric codecs offer great compression but suffer from low decoded audio quality and noise susceptibility (**APCodec**[^091]).

</td><td>

</td></tr>
<tr><td>

On the way to the neural codec, we first encountered hybrid codecs, which substituted some parametric codec modules with neural networks.
This type of codec improves performance by leveraging neural networks' adaptability.
Following that came vocoder-based approaches, which could leverage previously introduced neural vocoders to reconstruct audio signals by conditioning them on parametric coder codes or quantized acoustic features.
However, their performance and compression were still dependent on the handcrafted features received at the input (**AudioDec**[^092]).
The observation that separating models into modules prevents them from functioning effectively has inspired end-to-end auto-encoders (E2E AE) that accept raw waveforms as input and output.
A standard E2E AE is made up of four basic components: an encoder, a projector, a quantizer, and a decoder (**AudioDec**[^092]).
The basic use case is to take the raw waveform and use the encoder to construct a representation with reduced temporal resolution, which is then projected into a multidimensional space by the projector component.
To make the representations suitable for transmission and storage, we further quantize the projections into codes.
These codes make up a lookup table, which is used at the other end by the decoder to transform the quantized representations back to a raw waveform.
**NaturalSpeech2**[^093] defines the neural codec as a kind of neural network model that converts audio waveform into compact representations with a codec encoder and reconstructs audio waveform from these representations with a codec decoder.
The core idea is to use the audio codec to compress the speech or sound into a set of discrete tokens, and then the generation model is used to generate these tokens **HiFi-Codec**[^094].
They have been shown to allow for cross-modal tasks (**VioLA**[^095]).

</td><td>

</td></tr>
<tr><td>

Neural codec methods include **SoundStream**[^090], **EnCodec**[^089], **HiFi-Codec**[^094], **AudioDec**[^092], and **APCodec**[^091].
All the said methods use residual vector quantization (RVQ), while HiFi-Codec also introduced an extension called group-RVQ.
VQ methods will be talked about in [Section.05](#sec.architectures).
**SoundStream**[^090] is used by **AudioLM**[^096], **MusicLM**[^097], **SingSong**[^098] and **SoundStorm**[^099], while
**EnCodec**[^089] is used by **VALL-E**[^073], **VALL-E X**[^100], **Speech-X**[^101], and **VioLA**[^095].

</td><td>

</td></tr>
<tr><td>

Finally, despite the fact that neural codec approaches are relatively new, they have not been without criticism.
**NaturalSpeech2**[^093] noted that although RVQ can achieve acceptable reconstruction quality and low bitrate, they are meant for compression and transmission; therefore, they may not be suited as intermediate representations for audio production jobs.
This is because the sequence of discrete tokens created by RVQ can be very long, approximately $N$ times longer when $N$ residual quantifiers are utilized.
Because language models cannot handle extremely long sequences, we will encounter inaccurate predictions of discrete tokens, resulting in word skipping, word repetition, or speech collapse issues while attempting to reconstruct the speech waveform from these tokens.

</td><td>

</td></tr></table>

## 5.Architectures: 架构 <a id="sec.architectures"></a>

<table><tr><td width="50%">

As the models become more advanced, they start utilizing many different architectures in unison, making it impossible to categorize them efficiently.
Therefore, each subsection will contain models that fit into many subsections but have been divided up in the way the author thought made the most sense.
Unlike the audio features, there are many different architectures.
Here we will mention the architectures that have been most commonly used in the field of audio generation.

</td><td>

</td></tr></table>

### Auto-Encoders: 自编码器

<table><tr><td width="50%">

The majority of this section was taken from works by ([^102], [^103]).

The auto-encoder's objective is to duplicate the input into the output.
It consists of two parts: an encoder and a decoder.
The intersection of the two components depicts a code that attempts to represent both the input and, by extension, the output.
The encoder receives input data and changes it into a code that the decoder then uses to approximate the original input.
If we allowed arbitrary values in the encoder and decoder, we would obtain no meaningful code because it would simply simulate an identity function.
To obtain meaningful code, we constrain both the encoder and decoder, preventing them from just passing data through.
We can accomplish this by, for example, restricting the dimensionality of the values in the model.
The auto-encoder has the advantage of not requiring labeled data because it merely seeks to reconstruct the input, allowing for unsupervised learning.
[^104] demonstrates a basic use case for a simple auto-encoder, feature extraction.
While **VITS**[^105] connects two text-to-speech modules using VAE, enabling end-to-end learning in an adversarial setting.
Figure.2a depicts a simple auto-encoder setup using generic encoder and decoder components.

</td><td>

</td></tr>
<tr><td>

As this article focuses on generation, we will now introduce one of the most popular forms of the auto-encoder, the Variational Auto-Encoder (VAE) [^001].
VAE has been proposed to enable us to employ auto-encoders as generative models [^008].
The VAE components can be considered as a combination of two separately parameterized models, the recognition model and the generative model.
The VAE's success was mostly due to the choice of the Kullback-Leibler (KL) divergence as the loss function [^008].
KL will also be described in [Section.06](#sec.eval_metrics).
Unlike the auto-encoder, the VAE learns the parameters of a probability distribution rather than a compressed representation of the data [^005].
Modeling the probability distribution allows us to sample from the learned data distribution.
The Gaussian distribution is typically used for its generality [^004].
MusicVAE [^106] uses a hierarchical decoder in a recurrent VAE to avoid posterior collapse.
BUTTER [^107] creates a unified multi-model representation learning model using VAEs.
Music FaderNets [^108] introduces a Guassian Mixture VAE.
RAVE [^109] employs multi-stage training, initially with representation learning and then with adversarial fine-tuning.
Tango [^110] and **Make-An-Audio2**[^111] generate mel-spectrograms by using VAE in a diffusion model.

</td><td>

</td></tr>
<tr><td>

**Vector-Quantized VAE (VQ-VAE)** is an extension of VAE that places the latent representation in a discrete latent space.
VQ-VAE changes the auto-encoder structure by introducing a new component called the codebook.
The most significant change happens between the encoder and decoder, where the encoder's output is used in a nearest neighbor lookup utilizing the codebook.
In other words, the continuous value received from the encoder is quantized and mapped onto a discrete latent space that will be received by the decoder.
VQ-VAE replaces the KL divergence loss with negative log likelihood, codebook, and commitment losses.
One possible issue with the VQ-VAE is codebook collapse.
This occurs when the model stops using a piece of the codebook, indicating that it is no longer at full capacity.
It can result in decreased likelihoods and inadequate reconstruction [^075].
[^075] proposes the argmax auto-encoder as an alternative to VQ-VAE for music generation.
**MelGAN**[^112], VQVAE[^113], Jukebox[^114] with Hierarchical VQ-VAE, DiscreTalk[^115], FIGARO[^116], Diffsound[^117], and Im2Wav[^118] use VQ-VAE to compress the input to a lower-dimensional space.
While Dance2Music-GAN[^119], **SpeechT5**[^120], VQTTS[^121], and DelightfulTTS2[^122] only use the vector quantization.

</td><td>

</td></tr>
<tr><td>

Residual Vector Quantization (RVQ) improves VAE by computing the residual after quantization and further quantizing it using a second codebook, a third, and so on **EnCodec**[^089].
In other words, RVQ cascades $N$ layers of VQ where unquantized input vector is passed through a first VQ and quantization residuals are computed, then those residuals are iteratively quantized by an additional sequence of $N - 1$ vector quantizers **SoundStream**[^090].
[Section.04](#sec.audio_features) provides a list of models that employ RVQ.

</td><td>

</td></tr></table>

### Generative Adversarial Networks: 生成对抗网络

<table><tr><td width="50%">

Another prominent generating architecture is generative adversarial networks (GAN).
It is made up of two models that serve different purposes: the generator and the discriminator.
The generator's function is to convert a random input vector to a data sample.
The random vector is usually smaller because the generator mimics the decoder part of the auto-encoder [^001].
Unlike VAE, which imposes a distribution to generate realistic data, GAN utilizes a second network called the discriminator [^001].
It takes the generator's output or a sample from the dataset and attempts to classify it as either real or fake.
The generator is penalized based on the discriminator's ability to tell the difference between real and fake.
The opposite is also true: if the discriminator is unable to distinguish between the generator and the actual data points, it is penalized as well.
In other words, the two neural networks face off in a two-player minimax game.
According to [^123], the ideal outcome for network training is for the discriminator to be 50\% certain whether the input is real or bogus.
In practice, we train the generator through the discriminator by reducing the probability that the sample is fake, while the discriminator does the opposite for fake data and the same for real data.
Figure.02b illustrates the generator taking a random vector input and the discriminator attempting to distinguish between real and fake samples.

</td><td>

</td></tr>
<tr><td>

This basic setup allows us to generate samples resembling those in the dataset, but it doesn't let us condition the generation.
In other words, the random vector used in the generator does not match the semantic features of the data [^005].
Many datasets contain additional information about each sample, such as the type of object in an image.
It would be beneficial if we could use the additional information to condition the generator and generate from a subset of the learned outputs.
Conditional GAN (cGAN) induces additional structure by including additional information into the generator and discriminator inputs.
The generator adds the additional information to the random vector, whereas the discriminator adds it to the data to discriminate.
Some of the works that utilize cGAN are MidiNet[^124], [^125], [^126], [^127], and V2RA-GAN [^128].

</td><td>

</td></tr>
<tr><td>

Common issues with GAN include mode collapse, unstable training, and a lack of an evaluation metric [^002].
Mode collapse occurs when the generator focuses exclusively on a few outputs that can trick the discriminator into thinking they are real.
Even if the generator meets the discriminator requirements, we cannot use it to produce more than a few examples.
This might happen because the discriminator is unable to force the generator to be diverse [^123].
The Wasserstein GAN (WGAN) is a well-known variant for addressing this problem.
WGAN shifts the discriminator's job from distinguishing between real and forged data to computing the Wasserstein distance, commonly known as the Earth Mover's distance.
In addition, a modification to aid WGAN convergence has been proposed; it uses a gradient penalty rather than weight clipping and is known as WGAN-GP.
WGAN was used by MuseGAN [^129], WaveGAN [^130], TiFGAN [^131], and Catch-A-Waveform [^132].

</td><td>

</td></tr>
<tr><td>

Another popular modification to the GAN architecture is the use of deep convolutional networks known as deep convolutional GANs (DCGAN).
Unlike WGAN, DCGAN only requires a change to the model architecture, rather than the entire training procedure, for both the generator and discriminator.
It aims to provide a stable learning environment in an unsupervised setting by applying a set of architectural constraints [^123].
DGAN is used in works such as MidiNet [^124], WaveGAN [^130], and TiFGAN [^131].

</td><td>

</td></tr>
<tr><td>

Furthermore, it is worth noting a simple GAN extension designed to address the issue of vanishing gradients while simultaneously improving training stability.
Least squares GAN (LSGAN) improves the quality of generated samples by altering the discriminator's loss function.
Unlike the regular GAN, LSGAN penalizes correctly classified samples much more, pulling them toward the decision boundary, which allows LSGAN to generate samples that are closer to the real data [^133].
Papers using LSGAN include SEGAN [^134], [^135], HiFi-GAN [^136], Parallel WaveGAN [^137], Fre-GAN [^138], **VITS**[^105] and V2RA-GAN [^128].

</td><td>

</td></tr>
<tr><td>

There are many more modifications to GAN we haven't mentioned, like the Cycle GAN [^139] or the Boundary-Equilibrium GAN [^140], as we tried to showcase the most prevalent modifications in the field of audio generation.
Works like MelGAN [^112], GAAE [^141], GGAN [^142], SEANet [^143], EATS [^144], Dance2Music-GAN [^119] and Musika [^145]
use yet another type of loss called the hinge loss.

</td><td>

</td></tr>
<tr><td>

Finally, we'd like to mention works that were challenging to categorize.
They are GANSynth [^146], GAN-TTS [^147], RegNet [^148], Audeo [^149], Multi-Band MelGAN [^150], Multi-Singer [^151] and DelightfulTTS 2 [^122].

</td><td>

</td></tr></table>

### Normalizing Flows: 归一化流

<table><tr><td width="50%">

Although VAE and GAN were frequently utilized in audio generation, neither allowed for an exact evaluation of the probability density of new points [^152].
Normalizing Flows (NF) are a family of generative models with tractable distributions that enable exact density evaluation and sampling.
The network is made up of two "flows" that move in opposite directions.
One flow starts with a base density, which we call noise, and progresses to a more complex density.
The opposing flow reverses the direction, transforming the complex density back into the base density.
The movement from base to complex is known as the generating direction, whereas the reverse is known as the normalizing direction.
The term normalizing flow refers to the notion that the normalizing direction makes a complex distribution more regular, or normal.
The normal distribution is typically used for base density, which is another reason for the name.
Similar to how we layer transformations in a deep neural network, we compose several simple functions to generate complex behavior.
These functions cannot be chosen arbitrarily because the flow must be in both directions; hence, the functions chosen must be invertible.
Using a characteristic of the invertible function composition, we can create a likelihood-based estimation of the parameters that we can apply to train the model.
In this setup, data generation is simple; utilizing the generative flow, we can input a sample from the base distribution and generate the required complex distribution sample.
It has been formally proven that if you can build an arbitrarily complex transformation, you will be able to generate any distribution under reasonable assumptions [^152].

</td><td>

</td></tr>
<tr><td>

Depending on the nature of the function employed in the flow, there can be significant performance differences that impact training or inference time.
Inverse Autoregressive Flows (IAF) are a type of NF model with a specialized function that allows for efficient synthesis.
The transform is based on an autoregressive network, which means that the current output is only determined by the current and previous input values.
The advantage of this transformation is that the generative flow may be computed in parallel, allowing efficient use of resources such as the GPU.
Although IAF networks can be run in parallel during inference, training with maximum likelihood estimation requires sequential processing.
To allow for parallel training, a probability density distillation strategy is used **Parallel WaveNet**[^153]; **ClariNet**[^154].
In this method, we try to transfer knowledge from an already-trained teacher to a student model.
**Parallel WaveNet**[^153] and **ClariNet**[^154] are two IAF models that employ this method.
On the other hand, **WaveGlow**[^155], **FloWaveNet**[^156], and **Glow-TTS**[^157] all utilize an affine coupling layer.
Because this layer allows for both parallel training and inference, they can avoid the problems associated with the former.
Other efforts that are worth mentioning are WaveNODE [^158], which uses continuous normalizing flow, and **WaveFlow**[^159], which uses a dilated 2-D convolutional architecture.

</td><td>

</td></tr>
<tr><td>

At the end of this section, we'd like to address a problem that can arise when using flow-based networks with audio data.
Because audio is digitally stored in a discrete representation, training a continuous density model on discrete data might lead to poor model performance.
[^160] presented audio dequantization methods that can be deployed in flow-based networks and improved audio generating quality.

</td><td>

</td></tr></table>

### Transformer Networks: Transformer 网络

<table><tr><td width="50%">

% what is attention
% what is self-attention
% what is masked self-attention
% what is multi-head self-attention
% what is positional encoding
% encoder - decoder
% what encoder has
% what decoder has
% how encoder and decoder connect
% pros, cons of transformer

The majority of the material discussed in this section comes from [^161].

Before we can discuss transformers, we need to talk about attention.
Attention has three components: a query, keys, and values.
We have a database of (key, value) pairs, and our goal is to locate all values that closely match their key with the query.
In the transformer, we improve on this concept by introducing a new type of attention known as self-attention.
Self-attention includes three new functions that accept input and have learnable parameters.
The functions change the input into one of the three previously mentioned components: query, key, and value.
The prefix self refers to the fact that we utilize the same input for both the database and the query.
If we were to translate a sentence, we would expect the translation of the nth word to be determined not only by itself but also by the other words in the sentence.
For this example, the query would be the nth word and the database would be the sentence itself; if the parameters were learned correctly, we would expect to see relevant values for translation as the output of self-attention.
To boost the model's capacity to capture both short- and long-term dependencies, we can concatenate numerous self-attention modules, each with its own set of parameters, resulting in multi-head self-attention.
Furthermore, if we want to prevent the model from attending to future entries, we can use masked multi-head self-attention, which employs a mask to specify which future entries we wish to ignore.

</td><td>

</td></tr>
<tr><td>

The second essential element of the transformer is positional encoding.
Instead of processing a sequence one at a time, the self-attention in the transformer provides parallel computing.
The consequence is that the sequence's order is not preserved.
The prevailing method for preserving order information is to feed the model with additional input associated with each token.
These additional inputs are known as positional encodings.
Position encoding can be absolute or relative, and it can be predefined or learned during training.

</td><td>

</td></tr>
<tr><td>

At last, the transformer, like an auto-encoder, has both an encoder and a decoder.
Both the encoder and decoder are made up of a stack of identical layers, each with two sublayers.
The first sublayer is multi-head self-attention, whereas the second is a feed-forward network.
In addition, each identical layer contains a residual connection surrounding both sublayers that follows layer normalization.
Unlike the encoder, the decoder employs both encoder-decoder attention and masked multi-head self-attention at the input.
The encoder-decoder attention is a normal multi-head attention with queries from the decoder and (key, value) pairs from the encoder.
Before the input is fed into the network, positional embedding is applied.

</td><td>

</td></tr>
<tr><td>

Transformers were primarily intended for natural language processing but were then used for images with the vision transformer and lately for audio signals [^162].
They have revolutionized modern deep learning by providing the ability to model long-term sequences [^072].
On the other hand, transformers are generally referred to as data-hungry since they require a large amount of training data [^162].
The attention mechanism's quadratic complexity makes it difficult to process long sequences [^072].
To use transformers with audio, we would convert signals into visual spectrograms and divide them into "patches" that are then treated as separate input tokens, analogous to text [^162].
There are many works that use the transformer architecture, including Music Transformer [^163],
**FastSpeech**[^086] ve2Midi2Wave [^164], [^165], RobuTrans [^166], Jukebox [^114], **AlignTTS**[^167], Multi-Track Music Machine [^168], **JDI-T**[^169], **AdaSpeech**[^170], **FastPitch**[^171], [^072], Controllable Music Transformer [^172], [^173], **SpeechT5**[^120], CPS[^174], **FastSpeech2**[^087]; FIGARO[^116], HAT[^175], ELMG[^176], **AudioLM**[^096], **VALL-E**[^073], **MusicLM**[^097], SingSong[^098], **SPEAR-TTS**[^177], **AudioGen**[^178], **VALL-E X**[^100], **dGSLM**[^179], **VioLA**[^095], MuseCoco[^180], Im2Wav[^118], **AudioPaLM**[^181], VampNet[^182], LM-VC[^183], **UniAudio**[^184], and **MusicGen**[^185].

</td><td>

</td></tr>
<tr><td>

LakhNES [^186] and REMI [^187] use Transformer-XL, an extension of the Transformer that can, in theory, encode arbitrary long contexts into fixed-length representations.
This is accomplished by providing a recurrence mechanism [^188], wherein the preceding segment is cached for later usage as an expanded context for the subsequent segment.
Furthermore, to support the recurrence mechanism, it introduces an expanded positional encoding scheme known as relative positional encoding, which keeps positional information coherent when reusing states.
In addition to Transformer-XL, [^189] and [^190] presented Perceiver AR and Museformer as alternatives to tackle problems that require extended contexts.

</td><td>

</td></tr>
<tr><td>

Finally, another extension to the transformer has been successful for various speech tasks [^191].
Convolution-augmented Transformer (Conformer) extends the Transformer by incorporating convolution and self-attention between two feed-forward modules; this cascade of modules is a single Conformer block.
It integrates a relative positional encoding scheme, a method adopted from the described Transformer-XL to improve generalization for diverse input lengths [^192].
Papers utilizing the conformer are SpeechNet [^193], $\text{A}^3\text{T}$ [^191], VQTTS [^121], [^194], and **SoundStorm**[^099].

</td><td>

</td></tr></table>

### Diffusion Models: 扩散模型

<table><tr><td width="50%">

Diffusion models are generative models inspired by non-equilibrium thermodynamics [^011].
Diffusion models, like normalizing flows, consist of two processes: forward and reverse.
The forward process converts the data to a conventional Gaussian distribution by constructing a Markov chain of diffusion steps with a predetermined noise schedule.
The reverse method gradually reconstructs data samples from the noise using an interference noise schedule.
Unlike other architectures that change the distribution of data, such as variational auto-encoders and normalizing flows, diffusion models maintain the dimensionality of the latent variables fixed.
Because the dimensionality of the latent variables must be fixed during the iterative generation process, which can result in slow inference speed in high-dimensional spaces **AudioLDM**[^195].
A potential solution is to utilize a more compressed representation, such as a mel-spectrogram, instead of a short-time Fourier transform.
Papers employing diffusion models include **WaveGrad**[^196], **DiffWave**[^197], **Diff-TTS**[^198], **Grad-TTS**[^199], DiffuSE [^200], FastDiff [^201], CDiffuSE [^202], Guided-TTS [^203], Guided-TTS 2 [^204], DiffSinger [^205], UNIVERSE [^206], Diffsound [^117], Noise2Music [^207], DiffAVA [^208], MeLoDy [^209], Tango [^110], SRTNet [^210], MusicLDM [^211], JEN-1 [^212], **AudioLDM**[^195], [^213], ERNIE-Music [^214], and Re-AudioLDM [^215].

</td><td>

</td></tr>
<tr><td>

Transformer and diffusion models were the most popular designs discussed in this article.
As a result, in the final half of this chapter, we will list some works that use both the transformer and diffusion models.
These works include [^216], **Make-An-Audio2**[^111], **NaturalSpeech2**[^093], Grad-StyleSpeech [^217], **Make-An-Audio**[^218], **AudioLDM**[^219], and Moûsai [^220].

</td><td>

</td></tr></table>

## 6.Evaluation metrics: 评估指标

<a id="sec.eval_metrics"></a>

<table><tr><td width="50%">

Evaluations could be considered the most important piece of the puzzle.
By introducing evaluations, we are able to quantify progress.
We can compare, improve, and optimize our models, all thanks to evaluation metrics.
We will not mention domain-specific evaluation metrics such as the character error rate used in text-to-speech or the perceptual evaluation of speech quality used in speech enhancement.
There are many more widely used metrics that we will not mention in the following sections.
Some of them are: Nearest neighbor comparisons, Number of statistically-different bins, Kernel Inception Distance, and CLIP score.

</td><td>

</td></tr></table>

### Human Evaluation: 人类评估

<table><tr><td width="50%">

As humans, we are constantly exposed to various sorts of sounds, which provides us with a wealth of expertise when attempting to distinguish between real and manufactured audio.
The audio-generating method we are seeking to construct is intended to trick people into thinking the sound is a recording rather than synthesis.
As a result, who better to judge the success of such systems than the ones we're attempting to fool?
Human evaluation is the gold standard for assessing audio quality.
The human ear is particularly sensitive to irregularities, which are disruptive for the listener [^146].
Intuitively, it is simple to label an audio sample as good or bad, real or fake, but it is much more challenging to document a procedure derived from our thinking that may be used to evaluate future audio samples.
The human assessment is often carried out with a defined number of listeners who listen and rate the audio on a 1-5 Likert scale.
This type of test is termed the Mean-Opinion Score (MOS) [^221].
While MOS is used to evaluate naturalness, similarity MOS is used to assess how similar the generated and real samples are [^222].
Another metric, known as the comparative MOS, can be used to compare two systems by subtracting their MOS values.
We may also calculate it by providing listeners with two audio samples generated by different models and immediately judging which one is better [^165].
**Parallel WaveNet**[^153] discovered that preference scores from a paired comparison test, frequently referred to as the A/B test, were more reliable than the MOS score.
Many alternative human evaluation metrics have been proposed for music; domain-specific metrics include melody, groove, consonance, coherence, and integrity.
The biggest disadvantage of human evaluation is that the findings cannot be replicated exactly.
This means that the concrete numbers in the evaluation are unimportant, and only the link between them is crucial.
This stems from the inherent subjectivity of human evaluation as well as biases or predispositions for specific auditory features.

</td><td>

</td></tr></table>

### Inception Score: 初始分数

<table><tr><td width="50%">

The Inception Score (IS) is a perceptual metric that correlates with human evaluation.
The Inception score is calculated by applying a pretrained Inception classifier to the generative model's output.
The IS is defined as the mean Kullback-Leibler divergence between the conditional output class label distribution and the labels' marginal distribution.
It evaluates the diversity and quality of the audio outputs and prefers generated samples that the model can confidently classify.
With $N$ samples, the measure ranges from $1$ to $N$.
The IS is maximized when the classifier is confident in every classification of the generated sample and each label is predicted equally often [^130].
Normally, the Inception classifier is trained using the ImageNet dataset, which may not be compatible with audio spectrograms.
This will cause the classifier to be unable to separate the data into meaningful categories, resulting in a low IS score.
An extension to the IS called Modified Inception Score (mIS) measures the within-class diversity of samples in addition to the IS which favors sharp and clear samples **DiffWave**[^197].

</td><td>

</td></tr></table>

### Fréchet Distance: Fréchet 距离

<table><tr><td width="50%">

The inception score is based solely on the generated samples, not taking into consideration the real samples [^141].
The **Fréchet Inception Distance (FID)** score addresses this issue by comparing the generated samples with the real ones.
The FID calculates the Fréchet distance between two distributions for both generated and real samples using distribution parameters taken from the intermediate layer of the pretrained Inception Network [^141].
The lower the FID score, the higher the perceived generation quality.
It is frequently used to assess the fidelity of generated samples in the image generation domain [^117].
This metric was found to correlate with perceptual quality and diversity on synthetic distributions [^146].
The Inception Network is trained on the ImageNet dataset, which is purpose-built for images, but this does not ensure it will function for spectrograms.
It may be unable to classify the spectrograms into any meaningful categories, resulting in unsatisfactory results [^142].

</td><td>

</td></tr>
<tr><td>

**Fréchet Audio Distance (FAD)** is a perceptual metric adapted from the FID for the audio domain.
Unlike reference-based metrics, FAD measures the distance between the generated audio distribution and the real audio distribution using a pretrained audio classifier that does not use reference audio samples.
The VGGish model [^223] is used to extract the characteristics of both generated and real audio [^219].
As with the FID, the lower the score, the better the audio fidelity.
According to **AudioGen**[^178], the FAD correlates well with human perceptions of audio quality.
The FAD was found to be robust against noise, computationally efficient, consistent with human judgments, and sensitive to intra-class mode dropping [^079].
Although FAD may indicate good audio quality, it does not necessarily indicate that the sample is desired or relevant [^097].
For instance, in text-to-speech applications, low-FAD audio may be generated that does not match the input text.
According to [^147], the FAD measure is not appropriate for evaluating text-to-speech models since it was created for music.
While according to [^214], calculating the similarity between real and generated samples does not account for sample quality.
Another similar metric called the Fréchet DeepSpeech Distance (FDSD) also uses the Fréchet distance on audio features extracted by a speech recognition model [^008].
[^144] found the FDSD to be unreliable in their use case.

</td><td>

</td></tr>
<tr><td>

The last Fréchet metric that is important to discuss is the **Fréchet Distance (FD)**.
Unlike the FAD, which extracts features using the VGGish [^223] model, FD employs the PANN [^224] model.
The model change enables the FD to use different audio representations as input.
PANN [^224] uses mel-spectrogram as input, whereas VGGish [^223] uses raw waveform.
FD evaluates audio quality using an audio embedding model to measure the similarity between the embedding space of generations and that of targets [^211].

</td><td>

</td></tr></table>

### Kullback-Leibler Divergence: KL 散度

<table><tr><td width="50%">

**Kullback-Leibler (KL) divergence** is a reference-dependent metric that computes the divergence between the generated and reference audio distributions.
It uses a pretrained classifier to obtain the probabilities of generated and reference samples and then calculates the KL divergence between the distributions.
The probabilities are computed over the class predictions of the pretrained classifier.
A low KL divergence score may indicate that a generated audio sample shares concepts with the given reference [^212].
In music, this could indicate that the created audio has similar acoustic characteristics [^097].
While the FAD measure is more related to human perception [^110], the KL measure reflects more on the broader audio concepts occurring in the sample (**AudioGen**[^178]).

</td><td>

</td></tr></table>

## 7.Conclusions: 结论

<table><tr><td width="50%">

The development of deep learning methods has significantly changed the field of audio generation.
In this work, we have presented three important parts of building a deep learning model for the task of audio generation.
For audio representation, we have presented two long-standing champions and a third up-and-comer.
We explained five architectures and listed work that implements them in the field of audio generation.
Finally, we presented the four most common evaluations in the works we examined.
While the first three architectures mentioned above seem to have lost importance in recent years, the transformer and diffusion models seem to have taken their place.
This could be due to the popularization of large language models such as ChatGPT or, in the case of the diffusion models, diffusion-based text-to-image generators.

With the ever-increasing computing power and availability of large databases, it looks like the age of deep learning has only just begun.
Just as deep learning has allowed us to move from domain-dependent features and methods to a more universal solution, more recent work has attempted to move from a single task or purpose to a multi-task or even multi-modality model.

</td><td>

深度学习方法的发展极大地改变了音频生成领域.
在这项工作中, 我们展示了构建音频生成深度学习模型的三个重要部分.
对于音频表示, 我们介绍了两个长期以来的冠军和一个新兴的竞争者.
我们解释了五种架构, 并列出了在音频生成领域中实现它们的工作.
最后, 我们展示了在我们审查的工作中最常见的四种评估方法.

虽然上面提到的头三种架构在近年来似乎已经失去了重要性, Transformer 和扩散模型似乎已经取代了它们的位置.
这可能是因为大型语言模型如 ChatGPT 的流行, 或者在扩散模型的情况下, 基于扩散的文本到图像生成器的流行.

随着计算能力的不断提高, 以及大型数据库的可用性, 看起来深度学习的时代才刚刚开始.
正如深度学习使我们能够从依赖特定领域的特征和方法转向更通用的解决方案一样, 最近的工作试图从单一任务或目的转向多任务甚至多模态模型.

</td></tr></table>

## References: 参考文献

[^001]: [**Survey**: Deep Learning for Audio and Music.](S20210224.md) Multi-Faceted Deep Learning 2021.
[^002]: [**Survey**: Applications of Deep Learning to Audio Generation.](S20191120.md) IEEE@MCAS2019.
[^003]: [**Survey**: Deep Learning for Audio Signal Processing.](S20190430.md) IEEE@JSTSP2019.
[^004]: [**Survey**: Deep Learning Techniques for Music Generation - A Survey.](S20170905.md) ArXiv:1709.01620.
[^005]: [**Survey**: Deep Generative Models for Musical Audio Synthesis.](S20200610.md) ArXiv:2006.06426.
[^006]: [**survey**: A Survey on Neural Speech Synthesis.](S20210629.md) ArXiv:2106.15561.
[^007]: [**Survey**: A Survey on Audio Synthesis and Audio-Visual Multimodal Processing (2021)](S20210801.md) ArXiv:2108.00443.
[^008]: [**Survey**: Audio Representations for Deep Learning in Sound Synthesis: A Review (2021)](S20211130.md) IEEE/ACS@AICCSA2021.
[^009]: [**Survey**: Transformers in Speech Processing: A Survey](S20230321.md) ArXiv:2303.11607.
[^010]: [**Survey**: A Survey on Audio Diffusion Models: Text To Speech Synthesis and Enhancement in Generative AI (2023)](S20230323.md) ArXiv:2303.13336.
[^011]: [**Survey**: A Review of Deep Learning Techniques for Speech Processing (2023)](2023.04.30_A_Review_of_DL_Techniques_for_Speech_Processing_55P/Main.md) Information Fusion 2023.
[^012]: [**Survey**: Deep Learning for Acoustic Modeling in Parametric Speech Generation: A Systematic Review of Existing Techniques and Future Trends (2021)](S20150402.md) IEEE@MSP2015.
[^013]: Springer Handbook of Speech Processing. Springer2008.
[^014]: A Speech Parameter Generation Algorithm Considering Global Variance for HMM-Based Speech Synthesis. IEICE Transactions on Information and Systems 2007.
[^015]: Text-to-Speech Synthesis. Cambridge University Press 2009.
[^016]: Minimal Rules for Synthesizing Speech. The Journal of the Acoustical Society of America 1959.
[^017]: Speech Synthesis by Rule. Language and Speech 1964.
[^018]: Automatic Synthesis from Ordinary English Text. IEEE Transactions on Audio and Electroacoustics 1973.
[^019]: Structure of a Phonological Rule Component for a Synthesis-by-Rule Program. IEEE@TASLP1976.
[^020]: Terminal Analog Synthesis of Continuous Speech Using the Di-phone Method of Segment Assembly. IEEE Transactions on Audio and Electroacoustics 1968.
[^021]: Speech Synthesis by Rule Using an Optimal Selection of Non-Uniform Synthesis Units. IEEE@ICASSP1988.
[^022]: Unit Selection in a Concatenative Speech Synthesis System Using a Large Speech Database. IEEE@ICASSP1996.
[^023]: Statistical Parametric Speech Synthesis. Speech Communication. 2009.
[^024]:
[^025]:
[^026]:
[^027]:
[^028]:
[^029]:
[^030]:
[^031]:
[^032]:
[^033]:
[^034]:
[^035]:
[^036]:
[^037]:
[^038]:
[^039]:
[^040]:
[^041]:
[^042]:
[^043]:
[^044]:
[^045]:
[^046]:
[^047]:
[^048]:
[^049]:
[^050]:
[^051]:
[^052]:
[^053]:
[^054]:
[^055]:
[^056]:
[^057]:
[^058]:
[^059]:
[^060]:
[^061]:
[^062]:
[^063]:
[^064]:
[^065]:
[^066]:
[^067]:
[^068]:
[^069]:
[^070]:
[^071]:
[^072]:
[^073]: [**VALL-E**: Neural Codec Language Models Are Zero-Shot Text to Speech Synthesizers.](../Models/SpeechLM/ST2S/2023.01.05_VALL-E.md) ArXiv:2301.02111.
[^074]: [**WaveNet**: A Generative Model for Raw Audio.](../Models/Vocoder/2016.09.12_WaveNet.md) ArXiv:1609.03499.
[^075]:
[^076]:
[^077]:
[^078]:
[^079]:
[^080]:
[^081]:
[^082]:
[^083]:
[^084]:
[^085]:
[^086]:
[^087]:
[^088]:
[^089]:
[^090]:
[^091]:
[^092]:
[^093]:
[^094]:
[^095]:
[^096]:
[^097]:
[^098]:
[^099]:
[^100]:
[^101]:
[^102]:
[^103]:
[^104]:
[^105]:
[^106]:
[^107]:
[^108]:
[^109]:
[^110]:
[^111]:
[^112]:
[^113]:
[^114]:
[^115]:
[^116]:
[^117]:
[^118]:
[^119]:
[^120]:
[^121]:
[^122]:
[^123]:
[^124]:
[^125]:
[^126]:
[^127]:
[^128]:
[^129]:
[^130]:
[^131]:
[^132]:
[^133]:
[^134]:
[^135]:
[^136]:
[^137]:
[^138]:
[^139]:
[^140]:
[^141]:
[^142]:
[^143]:
[^144]:
[^145]:
[^146]:
[^147]:
[^148]:
[^149]:
[^150]:
[^151]:
[^152]:
[^153]:
[^154]:
[^155]:
[^156]:
[^157]:
[^158]:
[^159]:
[^160]:
[^161]:
[^162]:
[^163]:
[^164]:
[^165]:
[^166]:
[^167]:
[^168]:
[^169]:
[^170]:
[^171]:
[^172]:
[^173]:
[^174]:
[^175]:
[^176]:
[^177]:
[^178]:
[^179]:
[^180]:
[^181]:
[^182]:
[^183]:
[^184]:
[^185]:
[^186]:
[^187]:
[^188]:
[^189]:
[^190]:
[^191]:
[^192]:
[^193]:
[^194]:
[^195]:
[^196]:
[^197]:
[^198]:
[^199]:
[^200]:
[^201]:
[^202]:
[^203]:
[^204]:
[^205]:
[^206]:
[^207]:
[^208]:
[^209]:
[^210]:
[^211]:
[^212]:
[^213]:
[^214]:
[^215]:
[^216]:
[^217]:
[^218]:
[^219]:
[^220]:
[^221]:
[^222]:
[^223]:
[^224]: