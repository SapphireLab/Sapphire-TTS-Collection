# IntMeanFlow: Few-Step Speech Generation With Integral Velocity Distillation

<details>
<summary>基本信息</summary>

- 标题: "IntMeanFlow: Few-Step Speech Generation With Integral Velocity Distillation."
- 作者:
  - 01 Wei Wang
  - 02 Rong Cao
  - 03 Yi Guo
  - 04 Zhengyang Chen
  - 05 Kuan Chen
  - 06 Yuanyuan Huo
- 链接:
  - [ArXiv](https://arxiv.org/abs/2510.07979v1)
  - [Publication]()
  - [Github]()
  - [Demo]()
- 文件:
  - [ArXiv:2510.07979v1](PDF/2025.10.09_2510.07979v1_IntMeanFlow__Few-Step_Speech_Generation_With_Integral_Velocity_Distillation.pdf)
  - [Publication] #TODO

</details>

## Abstract

Flow-based generative models have greatly improved text-to-speech (TTS) synthesis quality, but inference speed remains limited by the iterative sampling process and multiple function evaluations (NFE).
The recent MeanFlow model accelerates generation by modeling average velocity instead of instantaneous velocity.
However, its direct application to TTS encounters challenges, including GPU memory overhead from Jacobian-vector products (JVP) and training instability due to self-bootstrap processes.
To address these issues, we introduce IntMeanFlow, a framework for few-step speech generation with integral velocity distillation.
By approximating average velocity with the teacher’s instantaneous velocity over a temporal interval, IntMeanFlow eliminates the need for JVPs and self-bootstrap, improving stability and reducing GPU memory usage.
We also propose the Optimal Step Sampling Search (O3S) algorithm, which identifies the model-specific optimal sampling steps, improving speech synthesis without additional inference overhead.
Experiments show that IntMeanFlow achieves 1-NFE inference for token-to-spectrogram and 3-NFE for text-to-spectrogram tasks while maintaining high-quality synthesis.
Demo samples are available\footnote{\url{https://vvwangvv.github.io/intmeanflow/}}.

## 1·Introduction

\label{sec:intro}

Text-to-speech (TTS) generation has made significant progress in recent years, with models achieving near-human-level, zero-shot synthesis capabilities[^Du2024CosyVoice], [^Du2025CosyVoice], [^Chen2024F5-TTS], [^Casanova2024Xtts], [^Casanova2022Yourtts], [^Anastassiou2024Seed-TTS], [^Zhu2025ZipVoice].

The rise of flow-based generative models[^Lipman2022Flow] has contributed to this advancement, offering promising results across various fields, including image synthesis[^Albergo2023Building], [^Liu2023Flow], video[^Jin2024Pyramidal] and music generation[^Prajwal2024MusicFlow].

These models learn to map data distributions to a latent space, enabling high-quality generation.

However, flow-based models often face a trade-off between sampling quality and efficiency, as their iterative sampling process can lead to slow inference and high computational costs.

To address this, recent efforts in the image domain, such as consistency models[^Liu2024Audiolcm], [^Fei2024Music], [^Song2023Consistency], [^Lu2024Simplifying,], [^Heek2024Multistep], [^Peng2025Flow-Anchored] and shortcut models[^Frans2025One], have been proposed to reduce the number of function evaluations~(NFE) while maintaining high-quality generation results.

Among these approaches, MeanFlow[^Geng2025Mean] has emerged as a promising solution to the trade-off between sampling quality and efficiency.

By modeling averaged velocity instead of instantaneous velocity, MeanFlow enables more efficient sampling without compromising output quality.

While it has shown success in image generation and audio generation[^Li2025MeanAudio], applying MeanFlow to TTS introduces several challenges.

First, the training process of MeanFlow relies on a self-bootstrap mechanism, which requires mixing with instantaneous velocity guidance similar to flow matching.

The strength of this guidance can significantly impact model performance, and without it, the model is prone to collapse.

Second, MeanFlow involves the Jacobian-vector product (JVP), a computationally intensive operation that consumes substantial GPU memory.

Additionally, JVP is not natively supported by certain custom CUDA operators or torch-native operations, such as flash attention, complicating the adaptation of existing models to the MeanFlow framework.

These memory and compatibility challenges make training large-scale TTS models with MeanFlow infeasible.

To address these challenges, we propose IntMeanFlow, a framework for few-step speech generation that leverages integral velocity distillation.

Building on the core motivation of MeanFlow, IntMeanFlow enables the model to learn averaged velocity instead of instantaneous velocity.

Motivated by the observation that the quality of speech generated by flow-based models plateaus after a certain NFE, we approximate the average velocity over a temporal interval $[t,r]$ by dividing the accumulated displacement between discrete time steps by the interval duration.

We further introduce an initialization strategy to leverage pretrained flow-matching models, enabling smoother migration from existing models.

By eliminating the need for self-bootstrap and reliance on the Jacobian-vector product (JVP), IntMeanFlow ensures improved stability, reduced GPU memory consumption during training, and better compatibility with existing models, simplifying the adaptation process.

Additionally, based on the empirical observation that denser sampling near noisier timesteps leads to better generation quality, we introduce the Optimal Step Sampling Search (O3S) algorithm.

O3S automatically identifies model-specific near-optimal sampling steps, using a customizable quality metric and a ternary search algorithm.

This improves the generation quality without introducing additional inference overhead.

We conduct experiments on models from two widely used approaches in flow-based TTS: (1) CosyVoice2[^Du2024CosyVoice], which integrates a language model (LM) followed by a flow model converting time-aligned tokens into mel-spectrograms (token2mel), and (2) F5-TTS[^Chen2024F5-TTS], where a flow model directly converts raw text embeddings into mel-spectrograms (text2mel), learning time alignment inherently.

Experimental results show that IntMeanFlow achieves 1-NFE inference for the token2mel task in CosyVoice2 and 3-NFE for the text2mel task in F5-TTS, maintaining high-quality synthesis.

Our contributions can be summarized as follows:

\begin{enumerate}[topsep=0pt]

-  We propose a distillation framework that applies MeanFlow to TTS, overcoming training memory overhead and stability issues associated with its direction application to TTS.

-  We introduce a search algorithm to identify model-specific sampling steps, improving generation efficiency without increasing inference overhead.

-  We evaluate our method on two popular flow-based TTS models, achieving 1-NFE inference for token2mel and 3-NFE for text2mel tasks, while maintaining high-quality synthesis.
\end{enumerate}

## 2·Related Works

\label{sec:related_works}

### Distillation based on Direct Metric Optimization

Consistency and shortcut models are commonly used to reduce NFE while maintaining output quality.

However, applying these methods to text-to-speech (TTS) has shown limited success due to task differences.

Notable exceptions, such as DMOSpeech[^Li2024Dmospeech] and DMOSpeech2[^Li2025DMOSpeech], reduce NFE in TTS through distillation and reinforcement learning.

However, these methods rely on auxiliary models that complicate the training process, as well as a fixed time sampling schedule during distillation, which reduces flexibility during inference.

In contrast, our approach eliminates the need for auxiliary models and additional loss functions.

And we do not employ a fixed step sampling strategy during training, which simplifies the training process, and improves flexibility during inference.

### MeanFlow

MeanFlow introduces a framework for one-step generative modeling by defining average velocity as displacement over a time interval.

Unlike Flow Matching, which models instantaneous velocity, MeanFlow focuses on learning average velocity and establishes an analytical relationship between average and instantaneous velocities through the MeanFlow Identity.

This approach provides a clear training objective without relying on heuristic constraints, and it operates independently of score estimation, pretraining, or distillation.

However, its dependence on Jacobian-vector products (JVPs) to compute the time derivative introduces computational overhead and limits scalability, especially with custom operators lacking JVP support.

## 3·Methodology

\label{sec:methodology}

### IntMeanFlow: MeanFlow Distillation via Integral Velocity

IntMeanFlow extends the principles of MeanFlow by focusing on learning the averaged velocity over a time interval, rather than the instantaneous velocity at individual time steps.

This approach retains the coarse-to-fine nature of MeanFlow, where smaller intervals are emphasized during training to capture fine-grained details, while broader temporal dynamics are learned more gradually.

In the distillation process, the student model is guided by a flow-matching teacher model.

The teacher model transforms an initial distribution \( p_0 \) (e.g., Gaussian noise) into a target distribution \( p_1 \) using a time-dependent vector field \( v(z_t, t; \theta) \).

The state evolution \( z_t \) is governed by the following ordinary differential equation (ODE):

$$
\frac{d}{dt} z_t = v(z_t, t; \theta), \quad z_0 \sim p_0, \quad z_1 \sim p_1, \quad t \in [0, 1]
$$

The teacher’s loss function is given by:

$$

L_{\text{CFM}} = \mathbb{E}_{t, p_0(z_0), q(z_1)} \left[ \left\| v(z_t, t; \theta) - (z_1 - z_0) \right\|^2 \right]
$$

While the teacher learns to model the instantaneous velocity \( v(z_t, t; \theta) \), the student model is tasked with learning the averaged velocity over a time interval \( [t, r] \), defined as:

$$
\bar{v}(z_t, t, r) = \frac{z_r - z_t}{r - t}
$$

where \( z_t \) and \( z_r \) are the states of the system at times \( t \) and \( r \), respectively. \( z_r \) is computed iteratively during inference as described below, and is not a direct parameter of the velocity function \( v \).

The student model is trained to approximate this averaged velocity using the teacher’s instantaneous velocity.

To achieve this, we perform iterative sampling during distillation.

The interval \( [t, r] \) is discretized into \( n \) subintervals, with time steps \( t_0 = t, t_1, \dots, t_n = r \).

At each step, the teacher model evolves the state according to the discrete approximation of the ODE:

$$
\label{eq:iterative-sampling}
z_{t_{k+1}} = z_{t_k} + (t_{k+1} - t_k) \cdot v(z_{t_k}, t_k; \theta)
$$

where \( t_0 = t \), \( t_n = r \), and \( t_1, t_2, \dots, t_{n-1} \) are intermediate time steps.

The total displacement over the interval \( [t, r] \) is given by:

$$
\Delta z^{\text{teacher}} = \sum_{k=0}^{n-1} \left( z_{t_{k+1}} - z_{t_k} \right) = \sum_{k=0}^{n-1} (t_{k+1} - t_k) \cdot v(z_{t_k}, t_k; \theta)
$$

This discrete displacement approximates the integral of the instantaneous velocity \( v(z_t, t; \theta) \) over \( [t, r] \), which is the continuous process the student is aiming to model.

To approximate the averaged velocity, the displacement is normalized by the interval length:

$$
\bar{v}_{\text{teacher}}(z_t, t, r) = \frac{\Delta z^{\text{teacher}}}{r - t}
$$

The continuous form of the averaged velocity is given by:

$$
\bar{v}(z_t, t, r) = \frac{1}{r - t} \int_t^r v(z_\tau, \tau; \theta) \, d\tau
$$

Thus, the teacher’s discrete displacement serves as a numerical approximation of this integral.

Finally, the student model is trained to minimize the distillation loss:

$$

L_{\text{distill}} = \mathbb{E}_{t, r} \left[ \left\| u_{\text{student}}(z_t, t, r) - \bar{v}_{\text{teacher}}(z_t, t, r) \right\|^2 \right]
$$

where \( u_{\text{student}}(z_t, t, r) \) is the predicted velocity from the student model, and \( \bar{v}_{\text{teacher}}(z_t, t, r) \) is the target velocity from the teacher.

The student model learns to predict the averaged velocity by following the teacher’s guidance, which approximates the integral of the instantaneous velocity via iterative sampling.

> <a id="fig:placeholder">![](imgs/imf.pdf)</a>

> Illustration of IntMeanFlow: The student model learns the averaged velocity from the instantaneous velocities provided by the teacher model at multiple states.

\vspace{-2em}

### Optimal Step Sampling Searching~(O3S)

In flow-based speech generation, previous work has shown that denser sampling at noisier steps leads to improved speech quality[^Chen2024F5-TTS], [^Zheng2025Accelerating].

To satisfy varying NFE requirements, earlier methods have used continuous functions or hard-coded discrete step schedules.

However, instead of relying on a fixed schedule, this work optimizes the steps sampling specifically for each model's inference process.

As shown in Fig.~[fig:o3s](#fig:o3s), we observe through experiments that speech quality, as a function of sampling step position, exhibits near-convex behavior.

This finding motivates the introduction of the Optimal Sampling Step Search (O3S) algorithm, which optimizes the distribution of a fixed number of sampling steps across the inference interval \( [0, 1] \).

The core idea behind O3S is to optimize the placement of each sampling step using ternary search.

To achieve this, we fix all but one of the sampling steps and apply ternary search to optimize the remaining one.

This process is repeated for each step, and the optimization continues until no further improvement is observed on a development set.

O3S thus identifies the optimal distribution of sampling steps, enhancing speech quality without increasing NFE.

The pipeline for O3S is outlined in Algorithm~[alg:o3s](#alg:o3s).

The metric function \( \mathcal{L} \) takes a set of sampling steps \( T \) and a development set for inference, computing a pre-defined metric on the generated audio.

In this work, we use speaker similarity as the metric.

\begin{algorithm}[h]
\caption{Optimal Step Sampling Search (O3S) Algorithm}
\label{alg:o3s}

\begin{algorithmic}[1]
\State Uniformly initialize \( \mathbf{T_{best}} \gets \{t_0, t_1, \dots, t_n\} \) where \( t_i = \frac{i}{n} \) % \Comment{Initialize the sampling steps}
\State Initialize best metric \(  \mathbf{m_{\text{best}}} \gets -\infty \), patience $p \gets 0$
\State Define metric function $\mathcal{L}$

\While{True}
\For{ \( i \in \{n-1, n-2, \dots, 1\} \)}
\State \( m_{\text{optim}}, T_{\text{optim}} \gets \text{TernarySearch}(\mathcal{L}, i, t_{i-1}, t_{i}) \) \Comment{find best placement for $t_i$ }
\If{ $m_{\text{optim}} > m_{\text{best}}$ }
\State \( T_{\text{best}}, m_{\text{best}} \gets T_{\text{optim}}, m_{\text{optim}}\)
\State $p \gets 0$
\Else
\State $p \gets p+1$
\If{ p = n}
\State **Break**
\EndIf
\EndIf
\EndFor
\EndWhile
\State **Return** $T_{\text{best}}, m_{\text{best}}$
\end{algorithmic}

\end{algorithm}

\vspace{-1em}

> <a id="fig:o3s">![](imgs/convex.pdf)</a>

> When fixing all but one of the sampling steps, the speaker similarity metric exhibits near-convex behavior.

### Initialization Strategy for IntMeanFlow

To adapt flow-matching models to IntMeanFlow, we introduce an additional parameter \( r \).

Both \( t \) and \( r \) are passed through the same embedding network, concatenated, and projected back to the feature space of \( t \) using a linear mapping \( \mathbf{W} \).

Let the embeddings for \( t \) and \( r \) be \( \mathbf{e}_t = \mathcal{E}(t) \) and \( \mathbf{e}_r = \mathcal{E}(r) \).

The concatenated and mapped embeddings $\mathbf{e}_{t,r}$, $\mathbf{e'}_{t,r}$ are:

$$
\mathbf{e}_{t, r} = [\mathbf{e}_t, \mathbf{e}_r]; \mathbf{e'}_{t,r} = \mathbf{W} \mathbf{e}_{t, r}
$$

To preserve the original model behavior, \( \mathbf{W} \) is initialized as:

$$
\mathbf{W} = 
\begin{bmatrix}

D_{diag} & 0 \end{bmatrix}

$$

where $D_{diag}$ indicates a diagonal matrix.

This ensures the model to behave like the original model at initialization.

<a id="tab:seedtts-test">Text2Mel results on Seed-TTS *test-en* and *test-zh*.

Bold indicates the best result, underlined the second-best.

All methods are based on F5-TTS.

IMF stands for IntMeanFlow.

Medium models have 592M parameters, base models 336M, and small models 158M.</a>

<a id="tab:cosyvoice-librispeech-pc">Token2Mel Results on LibriSpeech-PC: RTF values are reported only for the flow module.</a>

## 4·Experiments

\label{sec:experiments}
\vspace{-1em}

### Experiment Setup

We conduct experiments based on F5-TTS for the text2mel task and CosyVoice2 for the token2mel task.

During distillation with IntMeanFlow, the student model learns the vector field from the teacher with classifier-free guidance (CFG)[^Ho2021Classifier-Free], while the student avoids using CFG during training to reduce inference overhead.

For F5-TTS, we use the SeedTTS test set[^Anastassiou2024Seed-TTS]\footnote{\url{https://github.com/BytedanceSpeech/seed-tts-eval}}; for CosyVoice2, we use the LibriSpeech-PC test set[^Meister2023Librispeech-Pc].

Performance is evaluated on a cross-sentence task using a variety of metrics.

For objective evaluation, we report Word Error Rate (WER) and SIM-o (speaker similarity).

WER is computed using Whisperlarge-v3 for English transcription and Paraformer-zh[^Gao2022Paraformer] for Chinese transcription.

For SIM-o, we extract speaker embeddings using a WavLM-based[^Chen2022Wavlm] speaker verification model and compute the cosine similarity between synthesized and prompt human speech.

Real-time factors(RTF) are measured on NVIDIA A100 GPU.

For CMOS, speech quality is rated from 3 (worse) to + 3 (better) compared to human reference.

For SMOS, similarity between synthesized and prompt speech is rated on a 1–5 scale, with higher scores indicating better quality.

Additionally, we report UTMOS[^Saeki2022Utmos] scores, which are evaluated using an open-source MOS prediction model.

To complement UTMOS, we also apply the recent Uni-Versa-Ext (UV.MOS)[^Wang2025Improving], which has demonstrated a high correlation with human-provided MOS scores~\footnote{\url{https://huggingface.co/vvwangvv/universa-ext_wavlm-base_5metric}}.
\vspace{-1em}

### Results on Text2Mel Task

F5-TTS maps text embeddings to mel spectrograms in the text2mel task using a diffusion transformer.

Following [^Chen2024F5-TTS], We train small models on the LibriTTS[^Zen2019LibriTTS] dataset and base and medium models on the processed 95k-hour Emilia[^He2024Emilia] dataset.

Teachers' inference has a CFG rate of 3.0 while student does not apply CFG during inference.

Experimental results, shown in Table~[tab:seedtts-test](#tab:seedtts-test), demonstrate that distillation with IntMeanFlow significantly improves NFE and RTF, with only a slight compromise in performance.

The relationship between NFE and speech quality are illustrated in Fig.~[fig:nfe](#fig:nfe).

We do not compare with MeanFlow for the text2mel task, as F5-TTS requires training with a batch size of 1 due to JVP overhead.

Performance of MeanFlow is discussed in Section~[sec:token2mel](#sec:token2mel).

> <a id="fig:nfe">![](imgs/NFE.pdf)</a>

> NFE vs.
> 
> WER (\%) and SIM-o for the Flow Matching teacher and IntMeanFlow student models

#### Effectiveness of the O3S Algorithm

The comparison between lines 6 and 7 on *test-en* and lines 16 and 17 on *test-zh* demonstrates the effectiveness of applying the sampling steps optimized by O3S.

O3S consistently leads to improvements in both subjective and objective metrics by a large margin.

#### Impact of Teacher NFE on Training Time and Performance

Using a larger teacher NFE during distillation can significantly increase training time, as shown in Table~[tab:train_time](#tab:train_time).

To examine the trade-off between teacher NFE and student performance, we conduct ablation experiments.

A comparison of lines 10, 11, and 12 on *test-en*, and lines 18, 19, and 20 on *test-zh*, reveals that while a smaller teacher NFE results in minimal degradation in subjective metrics, objective metrics show noticeable performance loss, which is a common challenge in TTS evaluation.

Synthesized speech from lines 10 and 20 demonstrates unnatural pronunciation and degraded fluency due to the excessively small teacher NFE.
\vspace{-1em}

<a id="tab:train_time">Teacher NFE and training time per step</a>

#### Impact of Teacher Size on Student Performance

The size of the teacher model does not affect the inference efficiency of the student model.

Therefore, we examine whether a larger teacher can improve student performance, particularly when paired with a smaller, more practically efficient student model.

Comparing lines 11 and 12, we observe that increasing the teacher's size leads to improvements in both objective and subjective metrics for the student.

These improvements significantly surpass the baseline performance reported in line 4.

\vspace{-1em}

### Results on Token2Mel Task

\vspace{-.5em}
\label{sec:token2mel}

In this experiment, we use the CosyVoice 2 architecture for flow-based speech generation.

Unlike F5-TTS, where the flow operates on raw text embeddings, the flow in CosyVoice 2 processes time-aligned semantics, simplifying the task and enabling 1-NFE inference after distillation.

We perform distillation using the default model configuration from the official repository\footnote{\url{https://github.com/FunAudioLLM/CosyVoice}}
and its pre-trained checkpoint as the teacher model.

Since CosyVoice 2 is trained on a proprietary dataset that is unavailable to us, we use LibriTTS for distillation.

The vanilla MeanFlow model, as shown in line 18, yields good WER and SIM-o results but leads to degraded speech quality in both neural and human MOS evaluations, likely due to the absence of a teacher model and instability in the training process.

The results in line 9 demonstrate that IntMeanFlow effectively distills the teacher’s capabilities while reducing NFE, even when trained on a significantly smaller dataset.

\vspace{-1em}
